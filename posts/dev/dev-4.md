---
title: '형상 관리의 필요성'
date: '2024-12-31 00:00:00'
---

<p align='center'>
<img src='/images/symbol/26_git.svg' height='150px'>
</p>

코딩할 때 가장 유용한 기능 중 하나는 이전에 작성했던 코드를 되돌리는 **UNDO**다. 하지만 UNDO는 텍스트를 저장하는 **스택(stack)** 공간이 제한되어 있어, 간혹 이전 상태로 되돌리지 못해 난감한 상황을 겪을 때가 있다. 필자는 이를 '버전 소멸'이라고 부르는데, 이러한 문제를 방지하는 데 **SCM(소스 제어 관리, Source Control Management)** 은 매우 유용한 도구다.  

SCM을 사용하면 원격 저장소에 코드의 이전 버전을 항상 보존할 수 있어, 스택 공간의 한계로 인해 코드를 복구하지 못하더라도 원격 저장소에서 다시 가져오거나 특정 버전으로 되돌리면 된다. 개인적으로는 주로 **버전 소멸 방지**를 위해 SCM을 활용하지만, SCM의 또 다른 큰 장점은 **소스 공유**다. 학창 시절에는 USB, 메신저, 이메일 등을 통해 소스를 공유하곤 했는데, 이것이 얼마나 비효율적이었는지 실무에 들어가고 나서야 깨닫게 되었다. SCM은 소프트웨어 개발 및 유지보수 과정에서 발생하는 **소스 코드**나 **문서 변경**을 체계적으로 관리할 수 있는 도구다.

---

#### **SCM의 방식: 중앙 집중식과 분산형**
SCM은 **중앙 집중식**과 **분산형** 두 가지 방식으로 버전을 관리한다.

1. **중앙 집중식 버전 관리**  
   - 모든 파일이 중앙 서버에 저장되고, 클라이언트가 서버에 접근해 파일을 수정한다.  
   - 대표적인 예: **SVN(Subversion)**.  
   - SVN은 커밋(commit) 시 변경 사항이 바로 원격 서버에 반영된다.  

2. **분산형 버전 관리**  
   - 각 클라이언트가 로컬에 파일과 변경 기록을 저장하며, 원격 서버와 동기화를 수행한다.  
   - 대표적인 예: **Git**.  
   - Git은 파일 수정 후 원격 저장소에서 변경 사항을 먼저 가져오고(pull), 충돌(conflict)을 해결한 뒤, 커밋(commit)을 거쳐 별도로 원격 서버에 업로드(push)한다.  

---

#### **Git vs SVN: 충돌 관리 경험**  
SVN을 사용하던 시절, 사수와 충돌 해결 과정에서 의견이 충돌했던 경험이 많았다. 이런 이유로 개인적으로는 **충돌을 미연에 방지할 수 있는 Git**을 더 선호한다.  

다만, Git을 사용한다고 해서 충돌을 완벽히 방지할 수 있는 것은 아니다. 예를 들어, 내가 수정한 코드가 다른 사람이 수정한 코드와 충돌해 **pull 단계에서부터 작업이 중단**되는 경우도 있다. 이런 상황이 반복되면 생산성이 저하될 수 있으니, **효율적인 협업 규칙과 충돌 방지 전략**을 마련하는 것이 중요하다.  

---

#### **SCM을 넘어서**
SCM은 단순히 코드를 저장하거나 관리하는 도구가 아니라, 개발자 간의 협업과 프로젝트 성공을 뒷받침하는 핵심 기술이다. 특히 **효율적인 워크플로우 구축**, **자동화 도구와의 통합**, 그리고 **CI/CD(Continuous Integration/Continuous Deployment) 파이프라인**과의 연계를 통해 개발의 품질과 속도를 크게 향상시킬 수 있다.  

결국 SCM의 진정한 가치는 단순히 충돌을 피하거나 코드를 복구하는 데 그치지 않는다. 이는 개발자가 더 창의적인 작업에 집중하고, 팀 전체가 효율적으로 협력하며, 프로젝트의 목표를 효과적으로 달성할 수 있도록 돕는 데 있다. SCM을 잘 활용한다면, 그저 코드 관리 도구를 넘어 개발 생산성과 협업의 혁신적인 도구로 자리 잡을 것이다. 