---
title: '컨테이너의 필요성'
date: '2024-12-29 00:00:00'
---

<p align='center'>
<img src='/images/symbol/25_docker.svg' height='300px'>
</p>

### 패키지 관리에서 컨테이너화로: 확장성과 호환성의 고민 해결

아이폰의 등장은 단순히 모바일 앱 개발 기술의 발전을 이끌었을 뿐 아니라, 웹 기술 전반에도 큰 영향을 미쳤다. 하지만 기술 발전의 이면에는 라이브러리 호환성 문제라는 복잡한 도전이 따라왔다. 다양한 라이브러리가 쏟아져 나오면서, 서로 간에 호환되지 않는 경우가 빈번했고, 이는 개발자들에게 큰 골칫거리가 되었다.  

이러한 문제를 해결하기 위해 등장한 것이 **패키지 관리 도구**다. 예를 들어, 자바스크립트 환경에서는 **package.json** 파일을 통해 NPM(Node Package Manager)이 패키지를 통합적으로 관리한다. Java에서는 **Maven**이나 **Gradle**, C#에서는 **NuGet** 같은 도구들이 유사한 역할을 한다. 이들 도구 덕분에 패키지 관리의 생산성이 크게 향상되었고, 개발자들은 더 나은 효율로 작업할 수 있게 되었다.  

하지만 최근 소프트웨어 아키텍처는 점점 더 복잡해지고 있다. **마이크로서비스 아키텍처**의 부상으로 서버의 개수와 유형이 폭발적으로 증가하면서, 단순한 패키지 관리만으로는 해결되지 않는 문제들이 나타났다. 이런 변화는 **쿠버네티스**와 같은 오케스트레이션 기술의 필요성을 더욱 부각시켰다.  

### 현업 프로젝트 경험: 서버 확장과 호환성 문제  

현업 프로젝트의 경우, 초기에는 수 개에 불과하던 서버가 점점 늘어나더니 어느새 수십 개에 달했다. 서버가 많아지면서 자연스럽게 **모니터링과 관제**가 어려워졌고, 확장성 측면에서도 새로운 한계에 부딪혔다.  

형상 관리와 배포를 Git으로 수행하고 있었지만, 문제는 서버 간의 운영체제 유형과 버전 차이였다. 예컨대, 레거시 서버는 **Ubuntu 16.04 LTS**, 신규 서버는 **Ubuntu 18.04 LTS**로 운영체제가 달랐고, 이로 인해 설치된 **Python 버전**도 서로 달랐다. 이를 맞추지 않으면 애플리케이션 실행 중 오류가 발생했다. 결국, 운영체제 업그레이드 작업을 수십 번 반복해야만 했다.  

### 도커를 도입한 이유  

이런 비효율적인 상황을 해결하기 위해 도입한 것이 바로 **도커**였다. 서버를 추가할 때마다 환경 설정에 골머리를 앓는 일이 없어야 한다고 판단했다. P의 **Worker 서버**를 도커 컨테이너로 전환하고, 이를 **Docker Hub**에 업로드하여 필요한 경우 언제든 사용할 수 있도록 했다.  

새로운 서버를 추가하는 작업도 훨씬 간단해졌다. 이제는 단순히 도커를 설치하고, 이미지를 **docker pull** 명령어로 가져온 뒤 실행만 하면 됐다. 설치 과정과 시간은 대폭 단축되었고, 환경 차이로 인한 오류 걱정도 사라졌다.  

\`\`\`bash
docker pull myapp/worker:latest  
docker run -d myapp/worker:latest  
\`\`\`  

### 결론: 환경 관리를 넘어 확장성과 생산성의 향상  

도커 도입 후, 새로운 서버 환경을 맞추는 번거로움은 더 이상 존재하지 않았다. 컨테이너화 덕분에 환경 관리 문제를 해결했을 뿐만 아니라, 배포와 설치의 생산성도 크게 향상되었다. 기술의 발전은 단순히 문제를 해결하는 데서 그치지 않는다. 올바른 도구를 선택하고 활용하는 과정에서 더 나은 확장성과 효율성을 만들어낼 수 있다는 점, 그것이 이 경험에서 얻은 가장 큰 교훈이다.
    `
    },
    
    {
        articleType: 'dev',
        subType: 'share',
        postId: 'dev-4',
        title: '분산 처리: gRPC의 유용성',
        cover: '/images/symbol/18_grpc.svg',
        fit: 'hidden',
        createAt: '2024-12-30 00:00:00',
        editType: 'md',
        contents: `

<img src='/images/symbol/18_grpc.svg' height='300px'>

분산 처리 기술은 십여 년 전 Google의 Hadoop을 통해 주목받기 시작하면서 빠르게 발전해 왔다. 특히, Apache Hadoop 생태계는 그 폭과 깊이를 확장하며 세분화되어 갔다. 이와 같은 변화 속에서 분산 환경에서의 효율적인 데이터 교환 기술이 중요한 화두로 떠올랐고, 그중 필자는 **gRPC**를 가장 선호한다. 이를 제대로 이해하기 위해서는 먼저 <strong>RPC(Remote Procedure Call)</strong>의 개념을 알아야 한다.

<p align='center'>
<img src='/images/dev/dev-4-1.png'>
</p>

 RPC는 원격지에 위치하는 프로세스의 주소공간에 정의된 함수나 프로시저를 실행하여 프로세스 간의 통신을 수행하는 방법이다. RPC를 위해서는 IDL(Interface Definition Language)이라는 호출 규약이 정의되어야 한다. 서로 사양이 다른 두 프로세스가 통신을 하기 위해서는 IDL을 이용한 컴파일을 통해 클라이언트와 서버의 스터브(stub) 코드를 생성해야 한다. 스터브는 원격지의 프로세스를 대리하는 루틴으로, 클라이언트 혹은 서버의 객체를 대리하여 원격 프로세스의 요청을 받아들이고 응답을 전송한다. 또한 스터브는 객체가 요청한 데이터를 마샬링(marshaling)하여 상대방에게 전송하고, 작업이 완료된 데이터를 언마샬링(unmarshaling)하여 객체가 활용할 수 있는 형태로 변환한다.
 RPC는 분산 컴퓨팅 환경에서 유용하게 활용 가능하다. RPC를 이용하면 프로세스 간 양방향 통신을 비교적 쉽게 구현할 수 있으며, IDL을 기반으로 하기 때문에 프로그래밍 언어에 구애받지 않고 다양한 환경으로 시스템을 확장하기 용이하다.

gRPC는 구글이 개발한 원격 프로토콜 호출(RPC, Remote Protocol Call) 방식이다. gRPC는 데이터 전송을 위해 HTTP/2를 이용하고 프로토콜 버퍼(Protocol Buffer)라는 인터페이스 정의 언어(IDL, Interface Definition Language)를 사용하여 다른 프로세스의 메소드를 호출한다.

HTTP/2는 HTTP/1의 성능을 개선한 버전이다. HTTP/1은 기본적으로 클라이언트 요청에 서버가 응답하기 때문에 매 요청마다 커넥션(connection)을 생성해야 하며 쿠키를 포함한 헤더로 인해 용량이 크다. 반면 HTTP/2는 헤더 테이블과 호프만 인코딩 기법을 사용하여 헤더 정보를 압축하고, 서버가 클라이언트 요청 없이도 리소스를 전달할 수 있으며 하나의 커넥션만으로 데이터 교환이 가능하기 때문에 HTTP/1에 비하여 성능이 뛰어나다.

RPC를 이용하는 환경에서 클라이언트는 서버의 메소드를 직접 호출하여 데이터를 요청한다. 만약 서버와 클라이언트 구현에 사용된 프로그래밍 언어나 프레임워크가 서로 다르다면 동일한 데이터 구조임에도 불구하고 표현 방식이 달라 데이터 전송을 하지 못할 수 있다. 직렬화는 이처럼 상이한 시스템 환경에서 데이터 구조를 동일한 표현으로 변환하는 과정으로, 프로토콜 버퍼는 gRPC에서 사용하는 직렬화 데이터 표현 방식이다.

gPRC는 다양한 언어와 플랫폼에서 사용이 가능하고, RPC의 다른 방식 보다 구현이 쉽고 지원하는 기능 많고 성능이 우수하다. 또한 HTTP/2 기반이기 때문에 실시간 및 비동기식 데이터 전송, 푸시 서비스를 간단하게 구현할 수도 있다. 이러한 장점 덕분에 로컬환경 내의 애플리케이션 간 데이터 교환이나 마이크로서비스(Microservice)를 구축하기 위한 해법으로 많은 개발자들에 의해 채택되고 있다. 

- [gRPC 파이썬 예제보기](https://github.com/cerulean85/Sophia/blob/master/Task-oriented/gRPC/02.%20%EC%98%88%EC%A0%9C_Python.md)

- [gRPC Duplex Stream 예제](https://github.com/cerulean85/grpcDuplexStreamSample)